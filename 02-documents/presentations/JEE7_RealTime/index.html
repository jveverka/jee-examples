<!doctype html>
<html lang="en">
  <head>
	<meta charset="utf-8">
    <title>JEE7 real - time</title>
    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Juraj Veverka">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">    
    <link rel="stylesheet" href="../../../01-html-resources/presentations/css/custom.css">
    <link rel="stylesheet" href="../../../01-html-resources/presentations/css/reveal.css">
    <link rel="stylesheet" href="../../../01-html-resources/presentations/css/header-footer.css">
    <!-- <link rel="stylesheet" href="../_resources/css/theme/league.css" id="theme"> -->
    <!-- <link rel="stylesheet" href="_resources/css/theme/sky.css" id="theme"> -->
    <link rel="stylesheet" href="../../../01-html-resources/presentations/css/theme/beige.css" id="theme">
    <link rel="stylesheet" href="../../../01-html-resources/presentations/lib/css/zenburn.css">
  </head>
  <body>

    <div id="header-hidden">
       <div id="header">
          <!--
          <div id="header-left">HEADER-LEFT</div>
          <div id="header-right">HEADER-RIGHT</div>
          <div id="footer-left">FOOTER-LEFT</div>
          -->
       </div>
    </div>

    <div class="reveal">
      <div class="slides">
      
        <section>
          <h1>JEE7 Real-Time</h1>
          <h2>(web) applications</h2>
          <img class="embedded-image" data-src="images/wildfly_logo.svg"/>
        </section>

        <section>
          <table>
          <tr>
            <td> 
              <img class="embedded-image" data-src="images/juraj_veverka_photo.png"/>
            </td>
          </tr>
          <tr>  
            <td>
            <h3>Juraj Veverka</h3>
          Java and JEE developer with 10+ Years experience<br/>
          Participated on many international projects<br/>
          Participating on solution architecture designs<br/> 
          Solutions based on WildFly / Jetty ...<br/>
          Currently working on <a href="https://www.opendaylight.org/">OpenDaylight</a> project<br/>  
          Raspberry PI and IoT enthusiast<br/>
            </td>
          </tr>  
          </table>
        </section>

        <!-- INTRO - about -->
        <section>
          <h2>About this presentation</h2>
          <ul>
             <li>Not so traditional development approach</li>
             <li><strong>near real-time</strong> experience</li>
             <li>Servlet 3.1 and JAX-RS capabilities</li>
             <li><strong>WebSockets</strong> - of course !</li>
             <li>Beyond JEE - tips for improvements</li>
             <li><strong>What's expected</strong> in JEE8/9</li>
             <li>DEMO Included: <a href="https://github.com/jveverka/jee-examples/tree/master/HybridApplicationNG">HybridApplication</a></li>
             <li>Other examples: <a href="https://github.com/jveverka/jee-examples">jee-examples</a></li>
             <li>Not Included: hard real-time</li> 
          </ul>
        </section>

        <!-- INTRO - explain the scope: traditional JEE7 design patterns -->
        <section>
          <h2>JEE apps are usually ...</h2>
          <ul>
             <li><strong>Transactional</strong> - one transaction per request</li>
             <li><strong>Thread model</strong> - one thread per request</li>
             <li><strong>Request/Response</strong> - request->processing->response</li>
             <li><strong>DB centric</strong> - Hibernate/JPA with SQL database</li>
             <li><strong>Web Interface</strong> - server side rendering (JSF)</li>
             <li><strong>Monolithical</strong> - single war or few war/ears</li>
          </ul> 
        </section>

        <!-- INTRO - explain the scope: what problem we are addressing ? -->
        <section>
          <h2>JEE apps might be also ...</h2>
          <ul>
             <li><strong>Reactive</strong> - event driven client-server communication</li>
             <li><strong>Near Real-Time</strong> - low latency responses</li>
             <li><strong>Effective</strong> - better http stack utilization</li>
             <li><strong>Heterogeneous</strong> - support different client technologies</li>
             <li><strong>Full-duplex </strong> - communication with server during user's session.</li>
          </ul>
        </section>

        <section data-state="jee7TechnologiesState">
          <h2>JEE7 technologies</h2>
          <img class="embedded-image" data-src="images/JEE7-technologies.svg"/>
        </section>

        <section>
          <h2>JEE - Java clients</h2>
          <ul>
             <li>JEE technologies for JavaSE/JavaFX clients</li>
             <ul>
                <li>JMS - client server messaging</li>
                <li>Remote EJB calls</li>
                <li>ACC - Application Client Container</li>
             </ul>
          </ul>
        </section>

        <section>
          <img class="embedded-image" data-src="images/JEE_architecture.png" height="600"/>
        </section>

        <section>
          <h2>JEE - HTTP/All clients</h2>
          <ul>
             <li>JEE technologies for HTTP/HTML5 clients</li>
             <ul>
                <li>Servlet 3.1, JAX-RS 2.0 - REST APIs</li>
                <li>HTTP protocol upgrade</li>
                <li>WebSockets 1.0 - JSR356</li>
                <li>JSF - Java Server Faces *</li>
             </ul>
             <li>Integrates very well in heterogeneous environment</li>
             <li>Suitable for Web Browser clients</li>
             <li>Suitable M2M integrations</li>
          </lu>
        </section>

        <section>
          <h2>JSF ... is a problem</h2>
          <ul>
             <li>JSF is excellent for server-side rendering</li>
             <li>Problematic for real-time applications</li>
             <li><strong>Can be adapted for real-time</strong> user experience</li>
             <li>Combination of JSF, websockets, JavaScript</li>
          </ul>
        </section>
        
        <section>
          <h2>JSF and real-time</h2>
          <ul>
             <li>Use partial rendering on data change</li>
             <li>Independent JavaScript componets</li>
             <li>Some JSF libraries have support for websockets</li>
             <li>Primefaces - <strong>p:socket</strong> component</li>
             <li>Primefaces - <a href="http://www.primefaces.org/showcase/ui/ajax/remoteCommand.xhtml">p:remoteCommad</a> and custom JavaScript</li> 
          </ul>
        </section>

        <section>
          <h2>JSF and real-time</h2>
          <img class="embedded-image" data-src="images/JSF_real-time.screen.png"/>
        </section>

        <section>
          <h2>Primefaces real-time</h2>
          use p:remoteCommand in view 
          <pre><code>
&lt;h:form&gt;
    &lt;p:growl id="msgs" showDetail="true" /&gt;
    &lt;p:remoteCommand name="partialUpdate" update="msgs" 
        actionListener="#{remoteCommandView.execute}" /&gt;          
&lt;h:form&gt;
          </code></pre>
        </section>

        <section>
          <h2>Primefaces real-time</h2>
          <ul>
            <li>Use custom websocket connection</li>
            <li>Custom javascript to update view</li>
            <li>Easy to update JSF components and HTML/SVG in one view</li>
          </ul>  
          <pre><code>
function onMessage(message) {

   partialUpdate();
   //update other components
    
}          
          </code></pre>
        </section>

        <section>
          <img class="embedded-image" data-src="images/JSF.real-time.01.svg"/>
        </section>

        <section>
          <h2>HTTP protocol upgrade</h2>
          <ul>
             <li>Servlet 3.1 - Protocol upgrade</li>
             <li>Full duplex communication using own protocol</li>
             <ol>
                <li><strong>Handshake</strong> - protocol negotiation</li>
                <li><strong>Full duplex</strong> TCP connection</li>
                <li><strong>Close from client or server</strong></li>
             </ol>
             <li>Demo on Github: <a href="https://github.com/jveverka/jee-examples/tree/master/Servlets/servlet-04_protocol-upgrade">servlet-04_protocol-upgrade</a></li>
             <li>WebSocket is based on HTTP protocol upgrade</li>
          </ul>
        </section>

        <section>
          <h2>HTTP protocol upgrade</h2>
          1. Implement your<br>
          javax.servlet.http.HttpUpgradeHandler
          <pre><code>
public class CustomProtocoloUpgradeHandler implements HttpUpgradeHandler {
	@Override
	public void init(WebConnection webConnection) {
	   ServletInputStream is = webConnection.getInputStream(); 
	   ServletOutputStream os = webConnection.getOutputStream();
	   //handle read/write messages
	}

	@Override
	public void destroy() {
	}
}          
          </code></pre>
        </section>

        <section>
          <h2>HTTP protocol upgrade</h2>
          2. Use your HttpUpgradeHandler in servlet
          <pre><code>
@WebServlet(urlPatterns = { "/customProtocolEndpoint" })
public class ProtocolUpgradeServlet extends HttpServlet {
    @Override
    public void doGet(HttpServletRequest request, 
                      HttpServletResponse response) {
        String protocolName = request.getHeader("Upgrade");
        if (MessageUtils.PROTOCOL_NAME.equals(protocolName)) {
           response.setStatus(101);
           response.setHeader("Upgrade", MessageUtils.PROTOCOL_NAME);
           response.setHeader("Connection", "Upgrade");
           request.upgrade(CustomProtocoloUpgradeHandler.class);
        }
    }
}	
          </code></pre>
        </section>

        <section>
          <img class="embedded-image" data-src="images/Http.upgrade.svg"/>
        </section>

        <section>
          <h2>HTTP protocol upgrade - advandages</h2>
          <ul>
             <li>Usually only one open port 8080, 443, ...</li>
             <li>Servlet container handles all inbound traffic</li>
             <li>Not limited to HTTP anymore</li>
             <li>Easy to intercept with Servlet filters</li>
             <li>Easier security setup</li>
             <li>Custom sessions and busienss logic</li>
          </ul>
        </section>

        <section>
          <h2>HTTP protocol upgrade</h2>
          <img class="embedded-image" data-src="images/Http.upgrade.architecture.svg"/>
        </section>

        <section>
          <h2>HTTP ServerPush hacks</h2>
          <ul>
                 <li>Polling - regular period</li>
                 <li>Long Polling - request timeout</li>
                 <li>Comet / Ajax</li>
                 <li>SSE - Server Sent Events</li>
          </ul>
        </section>

        <section>
          <h2>Is HTTP a problem !?</h2>
          <ul>
             <li>HTTP is <strong>stateless</strong></li>
             <li>HTTP is <strong>half-duplex</strong></li>
             <li>HTTP is <strong>verbose, complex, resource-wasteful</strong></li>
          </ul>
        </section>

        <section>
          <h2>Payload optimization</h2>
          <ul>
             <li><a href="https://developers.google.com/protocol-buffers/">Google Protocol Buffers</a></li>
             <li><strong>Better/Faster</strong> for serialization of structured data</li>
             <li>Supported languges - C, C++, C#, Go, Java, Python, Ruby, ...</li>
             <li><strong>Defines protocol contract</strong></li> 
             <li>Backward compatibility support</li> 
          </ul>
        </section>

        <section>
          <h2>JAX-RS with protocol buffers</h2>
          <ol>
             <li>Install <a href="https://github.com/google/protobuf/releases">protoc</a> or use maven or gradle plugins</li>
             <li>Write your protocol in <a href="https://developers.google.com/protocol-buffers/docs/proto3">proto3</a> language</li>
             <li>Compile .proto file into java using protoc</li>
             <li>Implement JAX-RS providers for writing/reading messages</li>
             <li>Use compiled java protocol and providers on server and client</li>
          </ol>
        </section>

        <section>
          <h2>JAX-RS with protocol buffers</h2>
          <ul>
             <li>Demo Github: <a href="https://github.com/jveverka/jee-examples/tree/master/Servlets/servlet-07_proto-buffers">servlet-07_proto-buffers</a></li>
             <li>Endpoints</li>
             <ul>
                <li><code>http://.../data/getAllUsers</code></li>
                <li><code>http://.../data/getUserByName?userName=john</code></li>
             </ul>
             <li>Supports <strong>'application/protobuf'</strong> media type</li>
          </ul>
        </section>

        <section>
          <h2>JAX-RS with protocol buffers</h2>
          1. Write your protocol in proto3
          <pre><code>
syntax = "proto3";
package users;
option java_package = "itx.protobuffers.common";
option java_outer_classname = "UsersProtoc";

message User {
    string userName = 1;
    string email = 2;
    string note = 3;
}

message UserList {
    repeated User user = 1;
}
          </code></pre>
        </section>

        <section>
          <h2>JAX-RS with protocol buffers</h2>
          2. Create JAX-RS Provider for reading and writing 
          <pre><code>
@Provider
@Produces("application/protobuf")
@Consumes("application/protobuf")
public class ProtoBufferProvider implements MessageBodyReader, MessageBodyWriter {          
	@Override
	public void writeTo(Object t, Class type, Type genericType, Annotation[] annotations, MediaType mediaType,
			MultivaluedMap httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {
			...
	}		
	@Override
	public Object readFrom(Class type, Type genericType, Annotation[] annotations, MediaType mediaType,
			MultivaluedMap httpHeaders, InputStream entityStream) throws IOException, WebApplicationException {
			...
	}
}			
          </code></pre>
        </section>  

        <section>
          <h2>JAX-RS with protocol buffers</h2>
          3. Create JAX-RS endpoint 
          <pre><code>
@Path("data")
public class ProtoBufferService {
	@GET
	@Produces("application/protobuf")
	@Path("getAllUsers")
	public Response getAllUsers() {
		return Response.ok(dataService.getAllUsers()).build();
	}

	@GET
	@Produces("application/protobuf")
	@Path("getUserByName")
	public Response getUserByName(@QueryParam("userName") String userName) {
		User user = dataService.getUserByName(userName);
		return Response.serverError().build();
	}
}          
          </code></pre>
        </section>

        <section>
          <h2>JAX-RS with protocol buffers</h2>
          4. Create JAX-RS client 
          <pre><code>
public static void main(String[] args) {

   Client client = ClientBuilder.newBuilder()
                   .register(ProtoBufferProvider.class)
                   .build(); 
   WebTarget target = client.target(config.getServiceURLUserList());
   Builder builder = target.request();
   UserList userList = builder.get(UserList.class);
   
}          
          </code></pre>
        </section>  

        <section>
          <h2>WebSockets</h2>
          <ul>
             <li><strong>Dramatic reduction</strong> in network latency and traffic.</li>
             <li>WebSocket frame is just <strong>2 bytes</strong> overhead.</li>
             <li>Mature JavaScript API.</li> 
             <li>Supports HTTP proxies, filtering, authentication.</li>
             <li>Suitable also <strong>for native</strong> client integration</li> 
          </ul>
        </section>

        <section>
          <h2>WebSockets</h2>
          <ul>
             <li>IETF - <a href="https://tools.ietf.org/html/rfc6455">RFC-6455</a></li>
             <li>JSR 356 - <a href="https://jcp.org/en/jsr/detail?id=356">Java API for WebSocket</a></li>
             <li>Protocol is an <strong>independent TCP-based</strong> protocol.</li>
             <li>Only relationship to HTTP is that its handshake is interpreted by
                 HTTP servers as an Upgrade request</li>   
             <li>WebSocket is thin layer on top of TCP</li>     
          </lu>
        </section>

        <section>
          <img class="embedded-image" data-src="images/WebSocket.svg"/>
        </section>
     
        <!--     
        <section>
          <h2>WebSocket protocol</h2>
          <ul>
              <li>WebSocket is thin layer on top of TCP</li>
              <li>adds a web origin-based security model for browsers</li>
              <li>adds an addressing and protocol naming mechanism to support
                  multiple services on one port and multiple host names on one IP
                  address
              </li>
              <li>layers a framing mechanism on top of TCP to get back to the IP
                  packet mechanism that TCP is built on, but without length limits
              </li>
              <li>includes an additional closing handshake in-band that is designed
                  to work in the presence of proxies and other intermediaries</li>
          </ul>
        </section>
        -->

        <section>
          <h2>WebSockets with proto buffers</h2>
          <ul>
             <li>We can go even faster !</li>
             <li>Easy to use proto messages instead JSOM or XML</li>
             <li><strong>Reuse existing REST API</strong> proto messages</li>
             <li><strong>@PathParam</strong> to process different message types</li>
             <li><strong>Wrapper</strong> message in case of single WS endpoint</li>  
          </ul>
        </section>

        <section>
          <h2>WebSockets with proto buffers</h2>
          Proto wrapper message
          <pre><code>
message WrapperMessage {
    oneof msg {
       LoginRequest loginRequest = 1;
       LoginResponse loginResponse = 2;
       TestRequest testRequest = 3;
       TestResponse testResponse = 4;
       ...
    }
}                 
          </code></pre>
        </section>

        <section>
          <h2>WebSockets with proto buffers</h2>
          Server or Client end-point
          <pre><code>
@ServerEndpoint("/ws/wsendpoint")
public class WSEndpoint {
    @OnMessage
    public void onMessage(String message, Session session) {
       //JSON or XML handling
    }
	
    @OnMessage
    public void onMessage(byte[] message, Session session) {
       WrapperMessage wm = WrapperMessage.parseFrom(message);
       int messageTypeId = wm.getMsgCase().getNumber();
       switch (messageTypeId) {
          //message handling by type
       }
    }
}          
          </code></pre>
        </section>

        <section>
          <h2>WebSockets with proto buffers</h2>
          Sending proto messages
          <pre><code>
public void sendMessage(Session session, Message message, 
                        boolean useBinary) throws IOException {
  if (useBinary) {
    message.writeTo(new ByteArrayOutputStream());
    ByteBuffer bb = ByteBuffer.wrap(entityOutputStream.toByteArray());
    session.getAsyncRemote().sendBinary(bb);
  } else {
    String jsonMessage = JsonFormat.printer()
                                   .includingDefaultValueFields()
                                   .print(message);
    session.getAsyncRemote().sendText(jsonMessage);
  }
}          
          </code></pre>
        </section>

        <section>
          <h2>Communication patterns</h2>
          <ul>
             <li>Simple set of data values</li>
             <ul>
               <li>Display set of immutable data values</li>
               <li>Sensor data, statisctics, ...</li>
             </ul>
             <li>Data series</li>
             <ul>
               <li>Time series data</li> 
               <li>Time charts, ...</li> 
             </ul>  
             <li>Client query results</li>
             <ul>
               <li>Results from database based on user query</li>
             </ul>
             <li>Combination of above</li>
          </lu>
        </section>

        <section>
          <img class="embedded-image" data-src="images/CommunicationPattern01.svg"/>
        </section>

        <section>
          <img class="embedded-image" data-src="images/CommunicationPattern02.svg"/>
        </section>

        <section>
          <img class="embedded-image" data-src="images/CommunicationPattern03.svg"/>
        </section>

        <section>
          <h2>Synchronization of sessions</h2>
          <ul>
             <li>For clients using HTTP session and WebSockets</li>
             <li>HttpsSession is usually bound to user identity</li>
             <li>WebSocket session is not bound to HttpSession</li>
             <li>Keep both session types in sync</li> 
             <li>Disconnect WebSockets on HttpSession timeout !</li> 
             <li>Unattended WebSockets may lead to security leaks</li>
             <li>Verify client identity on Websocket connect</li>
          </ul>
        </section>

        
        <section>
          <section>
             <h2>Demo: Hybrid Application</h2>
             <img class="embedded-image" data-src="images/HybridApp.architecture.svg"/>
          </section>
          <section>
             <h2>Demo: Hybrid Application</h2>
             <ul>
               <li>Clients</li>
               <ul>
                 <li>JavaScript - Bootstrap client</li>
                 <li>JavaFx - JVM fat client, UI</li>
                 <li>RPi - JVM WebSocket client </li>
               </ul>
               <li>Backend</li>
               <ul>
                 <li>JEE7 - single war deployed in WildFly 10 AS</li>
               </ul>
             </ul>
          </section>
          <section>
             <img class="embedded-image" data-src="images/HybridApp.architecture.svg"/>
          </section>
          <!--
          <section>
             <h2>Demo: Hybrid Application</h2>
             Communication protocols:
             <br/>
             <ul>
               <li>Web Browsers - JSON over HTTP 1.1</li>
               <ul>
                 <li>JSON over HTTP 1.1</li> 
                 <li>JSON over webSocket</li> 
               </ul>
               <li>JVM clients</li>
               <ul>
                 <li>proto3 over HTTP 1.1</li>
                 <li>proto3 over WebSocket</li>
                 <li>may use JSON as well</li>
               </ul>
               <li><strong>proto3</strong> - ready for C#, Python, Ruby ... clients !</li>
             </ul>
          </section>
          -->
          <section>
             <h2>Demo: Hybrid Application</h2>
             Application Topics:<br/>
             <ul>
               <li>/</li>
               <li>/devices</li>
               <li>/devices/{deviceId}</li>
               <li>/chat</li>
               <li>/chat/{roomId}</li>
               <li>/test</li>
             </ul>
             <br/>
          </section>
          <section>
             <img class="embedded-image" data-src="images/HybridApp.client01.svg"/>
          </section>
          <section>
             <img class="embedded-image" data-src="images/HybridApp.client02.svg"/>
          </section>
          <section>
             <img class="embedded-image" data-src="images/HybridApp.client03.svg"/>
          </section>
          <section>
             <h2>Demo: Hybrid Application</h2>
             Features:<br/>
             <ul>
                <li><strong>Admin</strong> - management of user sessions</li>
                <li><strong>Devices</strong> - control connected devices, sensor readings</li>
                <li><strong>Chat</strong> - in real time of course :)</li>
                <li><strong>Test</strong> - websocket performance tests</li>
             </ul>
          </section>
          <section>
             <img class="embedded-image" data-src="images/HybridApp.performance.testing.svg"/>
          </section>
          <section>
             <h2>Demo: Hybrid Application</h2>
             Performance testing using echo messages:<br/>
             <ul>
                <li>compare json/protocol buffer perfomance</li>
                <li>test different echo message sizes</li>
                <li>test test performance with complex messages</li>
                <li>calculate messges/s and RTT</li>
                <li>test against javascript/JavaFx/JavaSE clients</li>
                <li>test against Explorer, Edge, Chrome, Firefox</li>
                <li>test against x86_64 / ARMv6 / ARMv7 clients</li>
                <li>run tests in parallel</li> 
             </ul>
          </section>
          <section>
             <h2>Demo: Hybrid Application</h2>
             Echo message proto3<br/>
             <pre><code>
message EchoData {
   int32 jobId = 1;
   int32 ordinal = 2;
   string payload = 3;
   repeated EchoStructuredPayload structuredPayload = 4;
}

message EchoStructuredPayload {
   int64 timestamp = 1;
   string message = 2;
   double value = 3;
   bool active = 4; 
}             
             </code></pre>
          </section>
          <section>
             <h2>Demo: Hybrid Application</h2>
             Simple Echo message example in JSON<br/>
             <pre><code>
{
   jobId: 1,
   odinal: 32,
   payload: "xxx",
   structuredPayload: null
}             
             </code></pre>
          </section>
          <section>
             <h2>Demo: Hybrid Application</h2>
             Structured Echo message example in JSON<br/>
             <pre><code>
{
   jobId: 1,
   odinal: 32,
   payload: "hello java",
   structuredPayload: [ 
      { 
         timestamp: 1453546512, message: "messsage: 0",
         value: 125.215, active: true 
      },
      { 
         timestamp: 1453546515, message: "messsage: 1",
         value: 125.218, active: false 
      },
      ... 
   ] 
}             
             </code></pre>
          </section>
          <section>
             <img class="embedded-image" data-src="images/HybridApplication.screen01.png"/>
          </section>
          <section>
             <img class="embedded-image" data-src="images/HybridApplication.screen02.png"/>
          </section>
          <section>
             <img class="embedded-image" data-src="images/HybridApplication.screen03.png"/>
          </section>
          <section>
             <h2>Demo: Hybrid Application</h2>
             Raspberry PI stack:<br/>
             <img class="embedded-image" data-src="images/Raspberry_Pi_Stack.svg"/>
          </section>
          <section>
             <h2>Demo: Hybrid Application</h2>
             Raspberry PI schematics:<br/>
             <img class="embedded-image" data-src="images/Raspberry_Pi_Controller-schema.svg"/>
             <br/>
          </section>
          <section>
             <h2>Demo: Hybrid Application</h2>
             Raspberry PI hardware:<br/>
             <img class="embedded-image" data-src="images/IMG_2716.png" width="50%"/>
             <br/>
          </section>
          <section>
             <h2>Demo: Hybrid Application</h2>
             Raspberry PI resources:<br/>
             <ul>
                <li>PI ZERO, 1 MODEL A+, 2 MODEL B, 3 MODEL B</li>
                <li><a href="https://www.sparkfun.com/products/13763">HTU21D</a> - temperature and relative humidity sensor</li>
                <li><a href="https://www.adafruit.com/product/1603">BMP180</a> - bosch pressure and temperature sensor</li>
                <li><a href="http://pi4j.com/">pi4j</a> project</li>
                <li><a href="https://github.com/jveverka/itx-rpi-drivers">itx-rpi-drivers</a> - pi4j drivers</li>
                <li><a href="https://github.com/jveverka/jee-examples/tree/master/HybridApplicationNG/hybrid-app-rpi">rpi client</a> - websocket client</a></li>
             </ul>
          </section>
        </section>

        <section>
          <h2>Beyond JEE7: JCache</h2>
          <ul>
             <li>WildFly subsystem - infinispan</li>
             <li>In-Memory data store</li>
             <li>Used by wildfly internally</li>
             <ul>
                 <li>clustering</li>
                 <li>web container</li>
                 <li>ejb container</li>
                 <li>hibernate subsystem</li>
             </ul>
             <li>Local or distributed cache (clustering/HA)</li>
             <li>Data eviction strategies: <a href="https://docs.jboss.org/author/display/ISPN/Eviction">NONE, LRU, LIRS</a></li>
             <li>Data expiration strategies: time criteria</li>
             <li>Github demo: <a href="https://github.com/jveverka/jee-examples/tree/master/JCache/jcache-01-lab">jcache-01-lab</a></li>
          </ul>
        </section>

        <section>
          <h2>Beyond JEE7: JCache</h2>
          Define custom application cache<br/>
          standalone-full.xml
          <pre><code>
&lt;subsystem xmlns="urn:jboss:domain:infinispan:4.0"&gt;
  ...
  &lt;cache-container name="jcacheTest" default-cache="jcacheTestdb"&gt;
    &lt;local-cache name="jcacheTestdb"&gt;
      &lt;transaction mode="NON_XA"/&gt;
    &lt;local-cache&gt;
  &lt;/cache-container&gt;
  ...  
&lt;/subsystem&gt;          
          </pre></code>
        </section>  

        <section>
          <h2>Beyond JEE7: JCache</h2>
          Use it in your beans.
          <pre><code>
@Stateless
public class CacheAccessBean {
  @Resource(lookup="java:jboss/infinispan/container/jcacheTest")
  private CacheContainer container;
  private Cache&lt;String, String&gt; cache;

  @PostConstruct
  private void init() {
    cache = container.getCache();
  }
  
  public String getData(String key) {
    return cache.get(key);
  } 
}
          </pre></code>
        </section>  
                
        <section>
          <h2>Beyond JEE7: SWAGGER.io</h2>
          <ul>
             <li><a href="">swagger.io</a> - OpenAPI Specification</li>
             <li>Define a standard, language-agnostic interface to REST APIs</li>
             <li>Like WSDL but easier and better !</li>
             <li>Machine readable API</li>
             <li>Easier integrations in microservice ecosystem</li>
             <li>Easy to use with WildFly JAX-RS</li>
             <li>Github demo: <a href="https://github.com/jveverka/jee-examples/tree/master/Servlets/servlet-09_jaxrs-swagger">servlet-09_jaxrs-swagger</a></li>
          </ul>
        </section>

        <!-- JEE8 FUTURE IMPROVEMENTS -->        
        <section>
          <h2>Future improvements in JEE8</h2>
          <ul>
             <li>JEE8 standard - JSR366, Q3/2017</li>
             <li>Servlet 4.0, HTTP/2</li>
             <ul>
                <li>HTTP/2 - eficient and fast HTTP</li>
                <li>Server Sent Events - MediaType.SERVER_SENT_EVENT JAX-RS 2.1</li>
             </ul>
             <li>Easier security APIs</li> 
             <li>Async CDI events ?</li>
             <li>ALPN - Application Layer Protocol Negotioation ?</li>
          </ul>
        </section>

        <section>
          <h2>HTTP/2</h2>
          Advantages over HTTP/1.1  
          <ul>
             <li>Binary protocol - more efficient</li>
             <li>Is fully multiplexed, instead of ordered and blocking</li>
             <li>Can therefore reuse one TCP connection for parallelism</li>
             <li>Uses header compression to reduce overhead</li>
             <li>Allows servers to “push” responses proactively into client caches</li>
          </ul>
        </section>

        <section>
          <h2>JEE8 - Roadmap</h2>
          <ul>
             <li>As presented at JavaOne</li>
             <li>2017 - Finalize JEE8 specs</li>
             <li>2018 - Finalize JEE9 specs</li>
             <li>JEE8 & JEE9 - focus on cloud and micro-services.</li>
          </ul>
        </section>

        <section>
          <h3>Q&A</h3>
          <a href="https://github.com/jveverka/jee-examples">https://github.com/jveverka/jee-examples</a>
          <img class="embedded-image" data-src="images/qr_code.png"/>
        </section>
        
        <!-- REFERENCES -->        
        <section>
          <section>
            <h2>References</h2>
            <ul>
              <li><a href="https://github.com/jveverka/jee-examples"><strong>github/jveverka/jee-examples</strong></a> - this presentation with all examples</li>
              <li><a href="http://www.reactivemanifesto.org"><strong>The Reactive Manifesto</strong></a> - principles of reactive systems</li>
              <li><a href="https://developers.google.com/protocol-buffers/"><strong>Google Protocol Buffers</strong></a> - efficient message transport</li>
              <li><a href="http://lab.hakim.se/reveal-js/#/"><strong>Reveal JS</strong></a> - made this presentation possible, thanx!</li>
              <li><a href="http://www.yworks.com/products/yed"><strong>yEd</strong></a> - diagram and graph editor</li>
              <li><a href="http://www.itbuzzpress.com/ebooks/wildfly-10-ebook.html">WildFly 10 e-books</a></li>
            </ul>
          </section>
          <section>
            <h2>References - backup</h2>
            <ul>
              <li><a href="https://www.youtube.com/watch?v=0KArzAbaPWQ">JEE8 JAX-RS 2.1</a> at JavaOne</li> 
              <li><a href="https://www.youtube.com/watch?v=T9HPLLXjGzI">Servlet 4 0 Status Update</a> at JavaOne</li>
              <li><a href="https://www.youtube.com/watch?v=BwwR1C_Lvpc">Java EE Next HTTP 2 and REST Opportunities</a></li>
              <li><a href="http://www.mastertheboss.com/">www.mastertheboss.com</a></li>
            </ul>
          </section>
        </section>

      </div>
    </div>
    
	<script src="../../../01-html-resources/presentations/lib/js/head.min.js"></script>
	<script src="../../../01-html-resources/presentations/js/reveal.js"></script>
	<script src="../../../01-html-resources/presentations/js/jquery-3.1.0.min.js"></script>

	<script>
	var xxx;
	        var ddd;
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				transition: 'slide', // none/fade/slide/convex/concave/zoom
				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: '../../../01-html-resources/presentations/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../../../01-html-resources/presentations/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../../../01-html-resources/presentations/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../../../01-html-resources/presentations/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../../../01-html-resources/presentations/plugin/zoom-js/zoom.js', async: true },
					{ src: '../../../01-html-resources/presentations/plugin/notes/notes.js', async: true }
				]
			});
			
			Reveal.addEventListener( 'jee7TechnologiesState', function() {
			   console.log("jee7TechnologiesState: fired !");
			   //var elementsToHiglight = $("g[fill='rgb(255,204,153)']");//.css('fill','rgb(255,255,255)');
			   //var elementsToHiglight = $("#jee7TechologiesImage");//.css('fill','rgb(255,255,255)');
			   //var elementsToHiglight = $("g[fill='rgb(255,204,153)']",svgRoot);
			   //console.log(elementsToHiglight);
            }, false );

	        $(document).ready(function(){
			   console.log("document loaded");
			   //xxx = document.getElementById("jee7TechologiesImage");
			   //var iWindow = xxx.contentWindow;
			   //iWindow.addEventListener("load",function(){
			   //    console.log("svg loaded");
			   //    ddd = xxx.contentDocument || xxx.contentWindow.document;
    			   //var svgRoot  = xx.contentDocument.documentElement;
    			   //var elementsToHiglight = $("g[fill='rgb(255,204,153)']",svgRoot);
    			   //console.log(elementsToHiglight);
			   //});
			   //$("#jee7TechologiesImage").load(function() {
			   //    console.log("svg loaded");
			       //var doc = this.contentDocument || this.contentWindow.document;
			   //});
			   
			   /**
			    * insert header and footer into every slide
			    */ 
			   var header = $('#header').html();
               if ( window.location.search.match( /print-pdf/gi ) ) {
                    Reveal.addEventListener( 'ready', function( event ) {
                       $('.slide-background').append(header);
                    });
               } else {
                    $('div.reveal').append(header);
               }
	        });
	</script>
		    
  </body>
</html>
    
